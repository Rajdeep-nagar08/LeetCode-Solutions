
// Without UNION - FIND TECHNIQUE

/*
Concept

https://leetcode.com/problems/minimize-malware-spread/discuss/181186/python-dfs-solution-with-picture-to-explain-my-thought(with-extra-Chinese-explanation)

*/

/*

Ans= node from intitial vector that is present in biggest size component of graph and no other node from initial vector present in that component except this one

Because if such happened then if this node is not affected, then whole component will not affected by malware


if there is no such node, then return lowest node from initial vector( or 1st node of sorted initial vector))

*/



class Solution {
    int mx=INT_MIN;
    int ans=0;
    unordered_set<int>st;
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
        int n=graph.size();
        int m=graph[0].size();
     
        sort(initial.begin(), initial.end());
        
        for(int x: initial)
            st.insert(x);
    
        
        for(int i=0;i<initial.size();i++){
        int y=initial[i];
        vector<bool>vis(n,false);
         st.erase(y);
        int count=0;
        bool f=false;
            dfs(y,graph,vis,count,f);
            
            if(f==false){
                if(mx<count){
                    mx=count;
                    ans=y;
                }
            }
            
            st.insert(y);
    }
    
        if(mx==INT_MIN){
            return initial[0];
        }
        
        return ans;

    }
        
        void dfs(int start, vector<vector<int>>&graph, vector<bool>&vis,int &count,bool &f){

            vis[start]=true;
            count++;
           
            if(st.count(start)==1){
                 f=true;
                return;
            }
            
        //    for(int x:g[start]){
            for(int i=0;i<graph.size();i++){
                if(!vis[i] && graph[i][start]==1)
                    dfs(i,graph,vis,count,f);
            }
        }
        
};



// Union Find Method ....

/*
1. Apply union find so that you get number of components with size 
   of each component (Number of countries in the world with population each country)
2. now iterate over inital infected corona patient and try to find no of patient in each country.
3. those country have only one patient with larger population will be saved first 
   and countries having only one patient with same population then country having samller index 
   will be saved first.

*/

/*

class Solution{
vector<int>par;
    public:
    
 int minMalwareSpread(vector<vector<int>>&graph, vector<int>&initial){
    
     int n=graph.size();
     int m=graph[0].size();
     
     par.resize(n);
     
     for(int i=0;i<n;i++){
         par[i]=i;
     }
     
     for(int i=0;i<n;i++){
         for(int j=0;j<m;j++){
        if(graph[i][j]==1 && i!=j){
            par[find(i)]=find(j);
        }
       }
     }
     
     sort(initial.begin(), initial.end());
     
   int ans=initial[0];
     
     vector<int>ifc(n,0); //infected patients count
     vector<int>poc(n,0);  //population of country
     
     
     for(int x: initial){
         ifc[find(x)]++;
     }
     
     for(int i=0;i<n;i++){
         poc[find(i)]++;
     }
     
     int mx=INT_MIN;
     
     for(int x: initial){
        
         if(ifc[par[x]]==1 && poc[par[x]]>mx){
             mx=poc[par[x]];
             ans=x;
         }
     }
     
    return ans;  
 }
    
    
    int find(int x){
        if(par[x]==x)
            return par[x]=x;
        
        return par[x]=find(par[x]);
    }
    
    
};

*/

